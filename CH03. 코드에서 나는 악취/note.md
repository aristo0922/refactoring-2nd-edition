### 어떤 리팩터링 기법을 적용할지 모르겠다면 3장과 부록 B를 참고하자.

## 3.1 기이한 이름

- 가장 많이 사용하는 리팩터링
  <br/>: 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기<br/><br/>
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 가능성이 높다.
- 그래서 혼란스러운 이름을 잘 정리하다보면 코드가 훨씬 간결해질 때가 많다.
  <br/>
  <br/>

## 3.2 중복 코드

- 함수 추출하기
  <br/>: 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우(6.1)<br/><br/>
- 문장 슬라이스하기<br/>
  : 코드가 완전히 동일하지 않고 비슷하다면 그 부분을 모아보기(8.6)<br/><br/>
- 메서드 올리기
  <br/>: 같은 부모로부터 파생된 서브클래스에 코드 중복(12.1)
  <br/>
  <br/>

## 3.3 긴 함수

오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성된다.

- 코드가 끝없이 위임하는 방식으로 작성
- 간접 호출(indirection) 효과 : 코드를 이해/공유/선택하기 쉬워진다.
- 호출부와 선언부 사이를 왕복하는 부담
  <br/>-> 함수 이름을 잘 지어서 부담을 줄이자.<br/><br/>
  > 1. 주석을 달 부분은 무조건 함수로 만든다.
  > 2. 함수 이름은 동작 방식 보다는 의도/목적이 드러나게 짓는다.

<br/> 
- 함수 추출하기 <br/>: 함수를 짧게 만드는 대부분의 방법<br/><br/>

> - 매개변수의 수를 줄여 간결하게 하는 법?
>
> 1. 변수를 질의 함수로 바꾸기(7.4)
> 2. 매개변수 객체 만들기(6.8)
> 3. 객체 통째로 넘기기(11.4)

<br/>

코드가 한 줄이어도 설명할 필요가 있다면 함수로 추출해라.

> 1. 조건문 분해(10.1)
> 2. 함수를 추출하여 조건문 속을 함수 호출문 하나로 바꾼다.
> 3. switch 문이 여러개라면 조건부 로직을 다형성으로 바꾸기(10.4)

<br/><br/>

> 1. 반복문 쪼개기(8.7)
>
> - 반복문 코드에 적합한 이름이 떠오르지 않는다며 성격이 다른 두 작업이 섞여있기 때문일 수 있다.

<br/><br/>

## 3.4 긴 매개변수 목록

- 매개변수를 질의 함수로 바꾸기(11.5)
  <br/>: 다른 매개변수에서 값을 얻어올 수 있는 매개변수 처리<br/><br/>
- 객체 통째로 넘기기(11.4)
  <br/>: 사용 중인 데이터 구조에서 값을 뽑아 각각을 별개의 매개변수로 전달하는 코드 처리<br/><br/>
- 매개변수 객체 만들기(6.8)
  <br/>: 항상 함께 전달되는 매개변수 처리<br/><br/>
- 플래그 인수 제거하기(11.3)
  <br/>: 함수의 동작 방식을 정하는 플래그 역할 매개변수 처리<br/><br/>
- 여러 함수를 클래스로 묶기(6.9)
  <br/>: 여러 개의 함수가 특정 매개변수들의 값을 공통적으로 사용할 경우 처리<br/>

<br/><br/>

## 3.5 전역 데이터

### 전역변수, Global Data?

- 함수의 외부에서 선언된 변수
- 전역 변수는 프로그램의 어디에서나 접근할 수 있으며, 프로그램이 종료되어야만 메모리에서 사라짐
  <br/>
  -> 유령 같은 원격작용 : 코드베이스 어디에서든 건드릴 수 있고 누가 바꿨는지 찾아낼 수 없음
  <br/> -> 악취 중 악취
- 클래스 변수와 싱글톤에서도 같은 문제 발생

#### 싱글톤?

- 객체의 인스턴스를 한개만 생성되게 하는 패턴
  <br/><br/>

1. 변수 캡슐화하기
   <br/>: 변수 접근 범위 최소화
   > '무엇이든 많이 복용하면 독이 될 수 있다.' <br/> -파라켈수스

<br/><br/>

## 3.6 가변 데이터 Mutable Data

- 무분별한 데이터 수정으로 다른 곳에서 기댓값과 달라질 수 있다.
  <br/><br/>

1. 변수 캡슐화
   <br/>- 함수를 거쳐야만 값을 수정하도록 설계하여 변수를 감시
   <br/>- 이는 코드 개선하는 난이도를 낮춘다.<br/><br/>
2. 변수 쪼개기
   <br/>- 하나의 변수가 여러 용도로 사용되는 경우
   <br/>- 용도 별 독립 변수에 저장한다.
   <br/>- 문장 슬라이드하기, 함수 추출하기에 이용<br/><br/>
3. 질의함수와 변경함수 분리하기
   <br/> 부작용이 있는 코드를 호출할 수 없게 한다.
   <br/>- 필수불가결한 경우에만 API 호출<br/><br/>
4. 세터 제거하기.
   <br/>- 변수의 유효 범위를 줄인다
   <br/><br/>
5. 파생변수를 질의함수로 바꾸기(9.3)
   <br/>- 값을 다른 곳에서 설정할 수 없도록 가변데이터를 다룬다.
   <br/><br/>
6. 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기
   <br/>- 변수를 갱신하는 코드들의 유효범위를 제한
   <br/><br/>
7. 참조를 값으로 바꾸기(9.4)
   <br/>- 구조체에 내부 필드에 데이터를 담는 변수
   <br/>- 내부 필드를 직접 수정하지 않고 구조체를 통째로 교체
   <br/><br/>

## 3.7 뒤엉킨 변경

- 단일 책임 원칙(SRP: Single Responsibility Principle)이 지켜지지 않을 때<br/>
  -> 하나의 모듈이 서로 다른 이유로 여러 방식으로 변경되는 일이 많을 때

#### 단일책임 원칙이란?

- 단일모듈은 변경의 이유가 하나. 오직 하나여야만 한다는 설계 원칙.

> <br/>**[예시]** <br/><br/>
> 지원해야 할 데이터베이스가 추가될 경우 함수 세개를 변경
> <br/>금융 상품이 추가될 때마다 또다른 함수 네 개를 바꾸는 모듈이 존재
> <br/> _- 뒤엉킨 변경이 발생한다._<br/>
> <br/><br/>

- 데이터베이스 연동과 금융 상품 처리는 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야 프로그래밍이 편하다.
- 그래야 무언가를 수정할 때 해당 맥락의 코드만 이해해도 진행할 수 있다.

### if. 순차적으로 실행되는 게 자연스러운 맥락이라면

- ex. 데이터베이스에서 데이터를 가져와 금융 상품 로직에서 처리
- 단계 쪼개기
  <br/>- 다음 맥락에 필요한 데이터를 특정 데이터 구조에 담아 전달

### if. 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 자주 호출한다면

- 함수 옮기기
  <br/>- 각 맥락에 해당하는 적당한 모듈을 만들어서 관련 함수를 모은다.
  <br/> - 처리 과정 별이 맥락별로 구분
- 이 때, 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전 **_함수 추출하기_** 먼저 수행
- 모듈이 클래스라면 **_클래스 추출하기_**

<br/><br/>

## 3.8 산탄총 수술 Shotgun Surgery

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때
  <br/><br/>

1. 함수 옮기기, 필드 옮기기
   <br/>: 변경 대상들을 한 모듈에 묶는다.(8.1, 8.2)<br/><br/>
2. 여러 함수를 클래스로 묶기
   <br/> : 비슷한 데이터를 다루는 함수가 많다면(6.9)<br/><br/>
3. 단계 쪼개기
   <br/> : 묶은 함수들의 출력 결과를 묶어서 다음 단계로 전달(6.11)<br/><br/>
4. 함수 인라인하기, 클래스 인라인하기
   <br/>: 인라인 리팩터링으로 어설프게 분리된 로직 병합(6.2, 7.6)

<br/><br/>

|            | 뒤엉킨 변경             | 산탄총 수술          |
| ---------- | ----------------------- | -------------------- |
| 원인(공통) | 맥락을 잘 구분하지 못함 |
| 현상       | 한 코드에 섞여들어감    | 여러 코드에 흩뿌려짐 |
| 해법       | 맥락별로 분리           | 맥락별로 모음        |

<br/><br/>

## 3.9 기능 편애 Feature Envy

> 영역 안 상호작용 최대화, 영역 사이 상호작용 최소화

- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 **다른 모듈의 함수나 데이터와 상호작용을 할 일이 더 많을 때**

1. 함수 옮기기
2. 함수 추출하기

> <br/> **[위 내용을 거스르는 패턴]** <br/><br/>
>
> - 전략 패턴
>   <br/>: Strategy Pattern<br/><br/>
> - 방문자 패턴
>   <br/>: Visitor Pattern <br/><br/>
> - 켄트 벡의 자기 위임
>   <br/>: Self-Delegation<br/><br/>

<br/><br/>

## 3.10 데이터 뭉치

1. 필드 형태 데이터 뭉치 > 클래스 추출하기
2. 메서드 시그니처 데이터 뭉치 > 매개변수 만들기/ 객체 통째로 넘기기 : 매개변수 갯수 감소

### 어떤게 데이터 뭉치지?

- 값 하나를 삭제해보자.
- 나머지 데이터가 의미 없어진다면 바로 그 친구다.

#### 결국엔 클래스로 바꾸기

<br/><br/>

## 3.11 기본형 집착

### 문자열화 된 변수?

- 화폐, 좌표, 구간, 전화번호 등을 문자열로 취급
  <br/><br/>

1. 기본형을 객체로 바꾸기(7.3)
2. 타입 코드를 서브클래스로 바꾸기, 조건부 로직을 다형성으로 바꾸기
   <br/>: 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 씌였다면 (12.6, 10.4)

3. 클래스 추출하기, 매개변수 객체 만들기
   <br/>- 함께 몰려다니는 기본형 그룹도 데이터 뭉치
